# Linker and Loader

linker or loader最基本的任务就是，**把抽象的名字（人能使用的）绑定到具体实现的名字上（比如地址）**。

比如getline绑定到“可执行程序iosys模块的第612字节上”。

或者把“可执行程序iosys模块的第612字节上” 绑定到一个 具体的地址数字上。

## 地址绑定的历史

回顾一下历史上的编程。
程序员把汇编写在纸上，然后手工转成机器码(assembler‘s work)，再喂给机器。
如果程序员对汇编中地址使用符号进行替代，那么在转换的时候，得对所有使用该符号处进行替换。
如果要增删一行指令，那这个转换可能就得重新进行。

因此，assembler的出现解决了这个问题，assembler允许程序员用符号写汇编，然后自己将符号转换为地址。

如果程序改变，只需要重新跑一下assembler。（任务被交给了assembler)。

而在assembler出现之前就有了 重定位和库搜索 的linker。

因为有代码复用的问题，不可能每个人写全部的代码，肯定有库的出现。

解决办法是这样的：所有库内的子函数在编写的时候都认为自己从地址0开始，将地址绑定延后至子函数要link到main函数时。

在link时，对所有子函数进行重定位，包括main内的call等等。

而**这是没有OS的情况**，每个程序都独享整个机器的内存，汇编后只需要链接到固定的内存地址。

但是有了OS的概念，程序需要和OS以及其他程序共享内存，

这意味着 **程序真正运行的地址只有到了OS把程序load到内存的时候才能确定**。

因此，**最终的地址绑定从之前的link time被延后到了load time**.

这时，linker 和loader开始分工了。

**linker只做部分的地址绑定，给每个subprogram内使用相对地址**。

而**loader则负责最终的重定位步骤，把真正的地址赋值给subprogram**。

而当硬件重定位和虚拟内存的出现，**linker和loader又变得没那么复杂了，因此这时每个程序在逻辑上又独享整个内存了**。
程序可以被load到固定的地址，让硬件来完成Load time的重定位（虚拟地址->物理地址）。

当PC跑同一个程序的多份实例时，可能会想，**代码区是不变的，只有数据对每份实例是独特的**。
OS只需要对不变的部分有一个copy就可以，变的部分有多个copy。
因此，编译器和汇编器做了修改，可以创建多个section，比如一个section是read-only的code，另一个section是writeable data。
这就导致了 Linker得把不同section给结合起来，这样链接好的程序可以把Code放在一个地方，Data放在另一个地方。
